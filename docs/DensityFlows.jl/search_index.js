var documenterSearchIndex = {"docs":
[{"location":"api_coupling/#Couplings","page":"Couplings","title":"Couplings","text":"","category":"section"},{"location":"api_coupling/#Axes","page":"Couplings","title":"Axes","text":"","category":"section"},{"location":"api_coupling/","page":"Couplings","title":"Couplings","text":"Axes define and manipulate dimensions on which the CouplingLayer operates. Some dimensions are left unchanged while the others undergo an affine transformation.","category":"page"},{"location":"api_coupling/#DensityFlows.CouplingAxes","page":"Couplings","title":"DensityFlows.CouplingAxes","text":"CouplingAxes(d, mask; kws )\nCouplingAxes(d, j=d÷2; kws...)\n\nCreate axes for CouplingLayer.\n\nArguments\n\nd::Int: dimension of the flow.\nj::Int: dimension cut (default is d÷2).\nmask::AbstractVector{Int}: dimensions that are affected by the coupling.\nn::Int: number of conditions / parameters (default is 0).\nreverse::Bool: (default is false).\n\nThe dimension cut j specifies which dimensions are not modified by the layer.  If reverse is false the layer acts as the identity on dimensions (1, j). If reverse is true  the layer acts as the identity on dimensions (j+1, d).\n\n\n\n\n\n","category":"type"},{"location":"api_coupling/","page":"Couplings","title":"Couplings","text":"Axes can be manipulated with the following functions.","category":"page"},{"location":"api_coupling/#Base.reverse","page":"Couplings","title":"Base.reverse","text":"Base.reverse(axes)\n\nSwap the dimensions that are left unchanged by the layer. See also CouplingAxes.\n\n\n\n\n\n","category":"function"},{"location":"api_coupling/#Coupling-elements","page":"Couplings","title":"Coupling elements","text":"","category":"section"},{"location":"api_coupling/#DensityFlows.CouplingLayer","page":"Couplings","title":"DensityFlows.CouplingLayer","text":"CouplingLayer([T=RNVPCouplingLayer, ] axes; kws...)\nCouplingLayer([T=RNVPCouplingLayer, ] d, j = d ÷ 2; n=0, reverse=false, kws...)\nCouplingLayer([T=RNVPCouplingLayer, ] d, mask; n=0, kws...)\n\nCouplingLayer(t_net, axes)\nCouplingLayer(s_net, t_net, axes)\n\nCreate an CouplingLayer with NN models s and t.\n\nThe layer can be represented as a function f such that on dimensions where it does not act  like the identity it returns\n\n    f(x) = x * exp(s) + t quad rm ifforward\n\nand\n\n    f^-1(z) = exp(-s) * (z-t) quad rm ifbackward  \n\nBy default s and t are built with Dense neural networks.\n\nArguments\n\naxes::CouplingAxes.\nd::Int: dimension of the flow.\nj::Int: dimension cut (default is d÷2).\nmask::Vector{Int}: dimensions that are affected by the coupling.\n\nKeywords arguments\n\nn::Int: number of conditions / parameters (default is 0).\nhidden_dim::Int: number of hidden dimensions in s and t (default is 32).\nn_sublayers_t::Int: number of sublayers in t (default is 2).\nn_sublayers_s::Int: number of sublayers in s (default is 2).\nσ::Function: activation function (default is Flux.relu).\nbias::Bool: activate bias (default is true).\n\nExample\n\njulia> @summary CouplingLayer(3, [1, 3], n=2, hidden_dim=10, n_sublayers_s=1, σ=Flux.tanh)\nRNVPCouplingLayer | s_net > [3, 10, 2] (62 parameters)\n                  | t_net > [3, 10, 10, 2] (172 parameters)\n                  | axes  > (d,n)=(3,2); identity=(2), transformed=(1,3)\n\nSee also CouplingAxes.\n\n\n\n\n\n","category":"type"},{"location":"api_coupling/#DensityFlows.CouplingBlock","page":"Couplings","title":"DensityFlows.CouplingBlock","text":"CouplingBlock(layer_1, layer_2)\nCouplingBlock([T=RNVPCouplingLayer, ] first_axes; kws...)\nCouplingBlock([T=RNVPCouplingLayer, ] d, j = d ÷ 2; n=0, reverse=false, kws...)\nCouplingBlock([T=RNVPCouplingLayer, ] d, mask; n=0, kws...)\n\nCreate an block of two CouplingLayer with opposite / complementary axes.\n\nArguments\n\nfirst_axes::CouplingAxes: axes of the first layer.\nd::Int: dimension of the flow.\nj::Int: dimension cut (default is d÷2).\nmask::Vector{Int}: dimensions that are affected by the coupling.\n\nKeyword arguments\n\nhidden_dim::Int: number of hidden dimensions in s and t (default is 32).\nn_sublayers_t::Int: number of sublayers in t (default is 2).\nn_sublayers_s::Int: number of sublayers in s (default is 2).\nσ::Function: activation function (default is Flux.relu).\nbias::Bool: activate bias (default is true).).\n\nExample\n\njulia> @summary CouplingBlock(3, [1, 3], n=2, hidden_dim=10, n_sublayers_s=1, σ=Flux.tanh)\nRNVPCouplingLayer | s_net > [3, 10, 2] (62 parameters)\n                  | t_net > [3, 10, 10, 2] (172 parameters)\n                  | axes  > (d,n)=(3,2); identity=(2), transformed=(1,3)\nRNVPCouplingLayer | s_net > [4, 10, 1] (61 parameters)\n                  | t_net > [4, 10, 10, 1] (171 parameters)\n                  | axes  > (d,n)=(3,2); identity=(1,3), transformed=(2)\n\n\n\n\n\n","category":"type"},{"location":"api_coupling/#DensityFlows.RNVPCouplingLayer","page":"Couplings","title":"DensityFlows.RNVPCouplingLayer","text":"RNVPCouplingLayer(s_net, t_net, axes)\n\nStructure of a Real-Non-Volume-Preserving affine coupling layer.\n\nContains \n\n\n\n\n\n","category":"type"},{"location":"api_coupling/#Specific-functions","page":"Couplings","title":"Specific functions","text":"","category":"section"},{"location":"api_coupling/#DensityFlows.RNVP_backward","page":"Couplings","title":"DensityFlows.RNVP_backward","text":"RNVP_backward(s, t, u, axis_id, axis_af)\n\nReturn z = (u-t)*exp(s).\n\n\n\n\n\n","category":"function"},{"location":"api_data/#Data","page":"Data","title":"Data","text":"","category":"section"},{"location":"api_data/#Structures","page":"Data","title":"Structures","text":"","category":"section"},{"location":"api_data/#DensityFlows.DataArrays","page":"Data","title":"DensityFlows.DataArrays","text":"DataArrays(x, θ = dflt_θ(x); f_training = 0.9, f_validation = 0.1, rng = Random.default_rng())\n\nNormalised and partitioned data to feed the neural network.\n\nx must be of size (d, ...) where d is the number of physical dimensions.  θ must be of size (n, ...)where n is the number of parameters and every  other array dimensions in place of ... should match that of x. \n\nwarning: Warning\nData is partitioned along the second axis only. It is thus necessary to make sure that size(x, 2)  is large enough by swapping some of the dimensions if necessary.\n\nSee also DataPartition and MetaData.\n\n\n\n\n\n","category":"type"},{"location":"api_data/#DensityFlows.MetaData","page":"Data","title":"DensityFlows.MetaData","text":"MetaData(hash, θ_min, θ_max)\n\nMetadata containing an identification hash value and the boundaries of the parameters array θ.\n\n\n\n\n\n","category":"type"},{"location":"api_data/#DensityFlows.DataPartition","page":"Data","title":"DensityFlows.DataPartition","text":"DataPartition(n, f_training = 0.9, f_validation = 0.1, rng = Random.default_rng())\n\nRandom partition of the data.\n\nThe data is devided into a fraction f_training of training data and  a fraction f_validation of validation data. If f_training + f_validation < 1 the rest is kept as testing data. \n\n\n\n\n\n","category":"type"},{"location":"api_data/#Functions","page":"Data","title":"Functions","text":"","category":"section"},{"location":"api_data/#DensityFlows.dflt_θ","page":"Data","title":"DensityFlows.dflt_θ","text":"dflt_θ([T = Float32,] dims::Tuple)\ndflt_θ([T = Float32,] dims...)\ndflt_θ(x::AbstractArray)\n\nDefault value of the parameters, setting the first dimension to size 0.\n\nArguments are the same than zeros or ones. If an array x is passed returns an array of the same dimensions than x with the first dimension set to size 0.\n\nExamples\n\njulia> dflt_θ(2, 3)\n0×2×3 Array{Float32, 3}\n\njulia> dflt_θ(ones(2, 4, 5))\n0×4×5 Array{Float64, 3}\n\n\n\n\n\n","category":"function"},{"location":"api_data/#DensityFlows.minimum_θ","page":"Data","title":"DensityFlows.minimum_θ","text":"Minimin value of the input parameters.\n\n\n\n\n\n","category":"function"},{"location":"api_data/#DensityFlows.maximum_θ","page":"Data","title":"DensityFlows.maximum_θ","text":"Maximum value of the input parameters.\n\n\n\n\n\n","category":"function"},{"location":"api_data/#DensityFlows.normalize_input","page":"Data","title":"DensityFlows.normalize_input","text":"normalise_input(x, x_min, x_max)\n\nNormalize input between -1 1. \n\n    y = fracx - x_rm minx_rm max - x_rm min\n\nSee also normalize_input! and resize_output.\n\n\n\n\n\n","category":"function"},{"location":"api_data/#DensityFlows.normalize_input!","page":"Data","title":"DensityFlows.normalize_input!","text":"normalise_input!(x, x_min, x_max)\n\nNormalize input between -1 1 in place. \n\nSee also normalize_input and resize_output!.\n\n\n\n\n\n","category":"function"},{"location":"api_data/#DensityFlows.resize_output","page":"Data","title":"DensityFlows.resize_output","text":"normalise_input(x, x_min, x_max)\n\nResize the output between x_rm min x_rm max. \n\n    x = (x_rm max - x_rm min) y + x_rm min\n\nSee also resize_output! and normalize_input.\n\n\n\n\n\n","category":"function"},{"location":"api_data/#DensityFlows.resize_output!","page":"Data","title":"DensityFlows.resize_output!","text":"normalise_input!(x, x_min, x_max)\n\nResize the output between x_rm min x_rm max in place. \n\nSee also resize_output and normalize_input!.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Quick-start-guide","page":"Manual","title":"Quick start guide","text":"","category":"section"},{"location":"manual/#Example","page":"Manual","title":"Example","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"using DensityFlows\n\nx = rand(2, 5000);\n\ndata = DataArrays(x)\nflow = AffineCouplingFlow(3, data.metadata, n_sublayers_s=2, n_sublayers_t=2)","category":"page"},{"location":"api_overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"api_overview/#Structure","page":"Overview","title":"Structure","text":"","category":"section"},{"location":"api_overview/#DensityFlows.FlowElement","page":"Overview","title":"DensityFlows.FlowElement","text":"Building blocks of the flow \n\n\n\n\n\n","category":"type"},{"location":"api_overview/#DensityFlows.summarize","page":"Overview","title":"DensityFlows.summarize","text":"summarize(element)\n\nPrint a summary for the FlowElement element.\n\n\n\n\n\n","category":"function"},{"location":"api_overview/","page":"Overview","title":"Overview","text":"The hierarchy of types can be visualised from the following outputs  ","category":"page"},{"location":"api_overview/","page":"Overview","title":"Overview","text":"using DensityFlows\nCouplingLayer <: FlowElement\nRNVPCouplingLayer <: CouplingLayer","category":"page"},{"location":"api_overview/#Evaluation","page":"Overview","title":"Evaluation","text":"","category":"section"},{"location":"api_overview/#DensityFlows.backward","page":"Overview","title":"DensityFlows.backward","text":"backward(f, x [, θ=dflt_θ(x)])\n\nReturn f^-1(x  theta) and J_f^-1(x  theta) where theta is an array of parameters.\n\nArguments\n\nx::AbstractArray{T}: arguments to pass to the flow element.\nθ::AbstractArray{T}: parameters / conditions (default is dflt_θ).\n\n\n\n\n\n","category":"function"},{"location":"api_overview/#DensityFlows.forward","page":"Overview","title":"DensityFlows.forward","text":"forward(f, z [, θ=dflt_θ(z)])\n\nReturn f(z   theta) and J_f(z  theta) where theta is an array of parameters.\n\nArguments\n\nz::AbstractArray{T}: arguments to pass to the flow element.\nθ::AbstractArray{T}: parameters / conditions (default is dflt_θ).\n\n\n\n\n\n","category":"function"},{"location":"api_overview/#DensityFlows.forward!","page":"Overview","title":"DensityFlows.forward!","text":"forward!(f, z [, θ=dflt_θ(z)])\n\nReplace z by f(z   theta) where theta is an array of parameters.\n\nArguments\n\nz::AbstractArray{T}: arguments to pass to the flow element.\nθ::AbstractArray{T}: parameters / conditions (default is dflt_θ).\n\n\n\n\n\n","category":"function"},{"location":"api_overview/#Save-and-load","page":"Overview","title":"Save and load","text":"","category":"section"},{"location":"api_overview/#DensityFlows.save_element","page":"Overview","title":"DensityFlows.save_element","text":"save_element(directory, element; kws...)\n\nRecursively save the FlowElement element's weights in directory.\n\nSetting erase = true force deletes any existing directory with the same name.\n\n\n\n\n\n","category":"function"},{"location":"api_overview/#DensityFlows.load_element","page":"Overview","title":"DensityFlows.load_element","text":"load_element(directory)\n\nLoad any FlowElement saved in directory.\n\n\n\n\n\n","category":"function"},{"location":"api_overview/#Macros","page":"Overview","title":"Macros","text":"","category":"section"},{"location":"api_overview/#DensityFlows.@auto_forward!","page":"Overview","title":"DensityFlows.@auto_forward!","text":"auto_forward!(T)\n\nAutomatically define a forward! function for type T  from forward if there is no possible optimization to  be found in  writting a specific forward! function.\n\n\n\n\n\n","category":"macro"},{"location":"api_overview/#DensityFlows.@auto_functor","page":"Overview","title":"DensityFlows.@auto_functor","text":"auto_functor(T)\n\nAutomatically define a functor function for type T calling forward.\n\n\n\n\n\n","category":"macro"},{"location":"api_overview/#DensityFlows.@summary","page":"Overview","title":"DensityFlows.@summary","text":"auto_functor(element)\n\nCall summarize(element).\n\n\n\n\n\n","category":"macro"},{"location":"api_overview/#DensityFlows.@unconditional_wrapper","page":"Overview","title":"DensityFlows.@unconditional_wrapper","text":"unconditional_wrapper(funcs...)\n\nDefine the unconditional version of a function with signature f(::Flow, ::AbstractArray, ::AbstractArray) or f(::FlowElement, ::AbstractArray, ::AbstractArray).\n\nReplace f(obj, y, θ) = f(obj, y, dflt_θ(y))\n\n\n\n\n\n","category":"macro"},{"location":"api_flow/#Flow","page":"Flow","title":"Flow","text":"","category":"section"},{"location":"api_flow/#DensityFlows.Flow","page":"Flow","title":"DensityFlows.Flow","text":"Flow([base, ] model, data)\n\nCreate a Flow from a model FlowChain and for a specific data.\n\nThe data must be passed as a DataArrays. A spceific base distribution can be given, default is multivariate gaussian. \n\n\n\n\n\n","category":"type"},{"location":"api_flow/#Chains","page":"Flow","title":"Chains","text":"","category":"section"},{"location":"api_flow/#DensityFlows.FlowChain","page":"Flow","title":"DensityFlows.FlowChain","text":"FlowChain(elements::Tuple)\nFlowChain(elements...)\nFlowChain([T = CouplingBlock, ], n, args...; kwars... )\n\nInstanciate a chain of flow elements from a Tuple.\n\nPossible to directly pass the elements of a chain, or construct a chain of n identical blocks of type T, with args...  and kws... passed to the constructor of T.\n\n\n\n\n\n","category":"type"},{"location":"api_flow/#DensityFlows.concatenate","page":"Flow","title":"DensityFlows.concatenate","text":"concatenate(x::FlowChain...)\nconcatenate(x::FlowChain, y::FlowElement...)\nconcatenate(x::Union{Tuple, FlowElement}, y::FlowChain...)\n\nMake one FlowChain from multiple chains or adding flow elements.\n\n\n\n\n\n","category":"function"},{"location":"api_flow/#Density-evaluation","page":"Flow","title":"Density evaluation","text":"","category":"section"},{"location":"api_flow/#StatsBase.sample","page":"Flow","title":"StatsBase.sample","text":"sample([rng=default_rng(), ] flow, dims [, θ = dflt_θ(T, dims)] )\n\nSample the flow distribution.\n\nGive a sample of the flow distribution of size given by dims which can be an Integer, or NTuple of integers. The default random sampler is Random.default_rng() but any sampler of type Random.AbstractRNG can be used. \n\nIf the flow is conditional, θ can be passed as an array  of size (n, dims...) where n is the number of parameters  if θ different for at least two sampled points. Otherwise  θ can be given as a NTuple{n, T}. In that case all points  are drawn with the same θ parameter.\n\nExample\n\n# return a sample of size (20, 10)\nsample(flow, (20, 10))\n\n# return a sample of size (20, 10) at \n# parameter (1f0, 2f0) if flow is conditional\nsample(flow, (20, 10), (1f0, 2f0))\n\n\n\n\n\n","category":"function"},{"location":"api_flow/#Distributions.logpdf","page":"Flow","title":"Distributions.logpdf","text":"logpdf(flow, x [, θ = dflt_θ(x)])\n\nNatural logarithm of the probability density function given by the flow.\n\nArgument x can be given as an array of size (d, dims...) or as a Tuple of d vectors of each length. In the latter case, return the logpdf on a grid of values defined by these vectors.\n\nIf the flow is conditional, θ can be passed as an array  of size (n, dims...) where n is the number of parameters  if θ different for at least two sampled points. Otherwise  θ can be given as a NTuple{n, T}.\n\nwarning: Warning\nIf x is given as a Tuple of vectors,  θ must be passed as a NTuple{n, T}.\n\nExample\n\n# Give arrays in the training range of the flow\nx = range(1f0, 10f0, 40)\ny = range(-2.5f0, 11f0, 10)\nz = range(0.1f0, 2f0, 30)\n\n# For a given trained Flow 'flow' on 3 dimensions\nres = logpdf(flow, (x, y, z)) # if unconditional\nres = logpdf(flow, (x, y, z), (1f0, 2f0)) # if 2 conditions\n\n# using contour in Plots\ncontour(x, y, res[:, :, 1]')\ncontour(x, z, res[:, 4, :]')\n\nSee also pdf.\n\n\n\n\n\n","category":"function"},{"location":"api_flow/#Distributions.pdf","page":"Flow","title":"Distributions.pdf","text":"pdf(flow, x, [, θ = dflt_θ(x)])\n\nProbability density function given by the flow.\n\nSee also logpdf.\n\n\n\n\n\n","category":"function"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"julia> CouplingLayer <: FlowElement\ntrue","category":"page"}]
}
