var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/#Structure","page":"Public API","title":"Structure","text":"","category":"section"},{"location":"api/#DensityFlows.Flow","page":"Public API","title":"DensityFlows.Flow","text":"Normalizing flow \n\n\n\n\n\n","category":"type"},{"location":"api/#DensityFlows.FlowElement","page":"Public API","title":"DensityFlows.FlowElement","text":"Building blocks of the flow \n\n\n\n\n\n","category":"type"},{"location":"api/#DensityFlows.AffineCouplingElement","page":"Public API","title":"DensityFlows.AffineCouplingElement","text":"AffineCouplingElement <: FlowElement\n\n\n\n\n\n","category":"type"},{"location":"api/#DensityFlows.RNVPCouplingLayer","page":"Public API","title":"DensityFlows.RNVPCouplingLayer","text":"RNVPCouplingLayer <: AffineCouplingLayer\n\nCan be called as a functor f::RNVPCouplingLayer(z, θ=nothing) equivalent to forward(f, z, θ) \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Public API","title":"Public API","text":"The hierarchy of types can be visualised from the following outputs  ","category":"page"},{"location":"api/","page":"Public API","title":"Public API","text":"using DensityFlows\nAffineCouplingElement <: FlowElement\nAffineCouplingLayer <: AffineCouplingElement\nRNVPCouplingLayer <: AffineCouplingLayer","category":"page"},{"location":"api/#Axes","page":"Public API","title":"Axes","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Axes define and manipulate dimensions on which the AffineCouplingElement operates. Some dimensions are left unchanged while the others undergo an affine transformation.","category":"page"},{"location":"api/#DensityFlows.AffineCouplingAxes","page":"Public API","title":"DensityFlows.AffineCouplingAxes","text":"AffineCouplingAxes(d, n=0; kws...)\n\nCreate axes for AffineCouplingLayer.\n\nArguments\n\nd::Int: dimension of the flow.\nn::Int: number of conditions / parameters (default is 0).\nj::Int: dimension cut (default is d÷2).\nreverse::Bool: (default is false).\n\nThe dimension cut j specifies which dimensions are not modified by the layer.  If reverse is false the layer acts as the identity on dimensions (1, j). If reverse is true  the layer acts as the identity on dimensions (j+1, d).\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Public API","title":"Public API","text":"Axes can be manipulated with the following functions.","category":"page"},{"location":"api/#Base.reverse","page":"Public API","title":"Base.reverse","text":"Base.reverse(axes)\n\nSwap the dimensions that are left unchanged by the layer. See also AffineCouplingAxes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Coupling-elements","page":"Public API","title":"Coupling elements","text":"","category":"section"},{"location":"api/#DensityFlows.AffineCouplingLayer","page":"Public API","title":"DensityFlows.AffineCouplingLayer","text":"AffineCouplingLayer(axes; kws...)\nAffineCouplingLayer(d, n=0; kws...)\n\nCreate an AffineCouplingLayer with NN models s and t.\n\nThe layer can be represented as a function f such that on dimensions where it does not act  like the identity it returns\n\n    f(x) = x * exp(s) + t quad rm ifforward\n\nand\n\n    f^-1(z) = exp(-s) * (z-t) quad rm ifbackward  \n\nArguments\n\naxes::AffineCouplingAxes.\nd::Int: dimension of the flow.\nn::Int: number of conditions / parameters (default is 0).\nj::Int: dimension cut (default is d÷2).\nreverse::Bool: (default is false).\nhidden_dim::Int: number of hidden dimensions in s and t (default is 32).\nn_sublayers_t::Int: number of sublayers in t (default is 2).\nn_sublayers_s::Int: number of sublayers in s (default is 2).\n\nIf axes is provided, then d, n, j and reverse should not be passed as arguments as they would be redondant. \n\nThe dimension cut j specifies which dimensions are not modified by the layer.  If reverse is false the layer acts as the identity on dimensions (1, j). If reverse is true  the layer acts as the identity on dimensions (j+1, d).\n\nSee also AffineCouplingAxes.\n\n\n\n\n\n","category":"type"},{"location":"api/#DensityFlows.AffineCouplingBlock","page":"Public API","title":"DensityFlows.AffineCouplingBlock","text":"AffineCouplingBlock(axes; kws...)\n\nCreate an block of two AffineCouplingLayer with opposite axes.\n\nOpposite axes here means that one is set with reverse = true  and the other with reverse = false.\n\nArguments\n\naxes::AffineCouplingAxes.\nhidden_dim::Int: number of hidden dimensions in s and t (default is 32).\nn_sublayers_t::Int: number of sublayers in t (default is 2).\nn_sublayers_s::Int: number of sublayers in s (default is 2).\n\n\n\n\n\n","category":"type"},{"location":"api/#Chains","page":"Public API","title":"Chains","text":"","category":"section"},{"location":"api/#DensityFlows.AffineCouplingChain","page":"Public API","title":"DensityFlows.AffineCouplingChain","text":"AffineCouplingChain(n_couplings, axes, U; kws...)\nAffineCouplingChain(xs...)\n\nCreate an chain of AffineCouplingLayer or AffineCouplingBlock.\n\nCan either create a chain of n_couplings similar layers or blocks by passing n_couplings and axes or instantiate a chain from pre-existings layers or  blocks passed as xs.\n\nArguments\n\nn_couplings::Int: number of couplings.\naxes::AffineCouplingAxes.\nU:Type: type of struct in the chain, can be AffineCouplingLayer or AffineCouplingBlock (default is AffineCouplingBlock).\n\nKeywords arguments kws... are passed to the constructor of AffineCouplingLayer or AffineCouplingBlock.\n\n\n\n\n\n","category":"type"},{"location":"api/#Evaluation","page":"Public API","title":"Evaluation","text":"","category":"section"},{"location":"api/#DensityFlows.backward","page":"Public API","title":"DensityFlows.backward","text":"backward(f, x, θ=nothing)\n\nReturn f^-1(x  theta) and J_f^-1(x  theta) where theta is an array of parameters.\n\nArguments\n\nx::AbstractArray{T, N}: arguments to pass to the flow element.\nθ::Union{AbstractArray{T, N}, Nothing}: parameters / conditions (default is nothing).\n\n\n\n\n\n","category":"function"},{"location":"api/#DensityFlows.forward","page":"Public API","title":"DensityFlows.forward","text":"forward(f, x, θ=nothing)\n\nReturn f(z   theta) and J_f(z  theta) where theta is an array of parameters.\n\nArguments\n\nz::AbstractArray{T, N}: arguments to pass to the flow element.\nθ::Union{AbstractArray{T, N}, Nothing}: parameters / conditions (default is nothing).\n\n\n\n\n\n","category":"function"},{"location":"api/#Save-and-loads","page":"Public API","title":"Save and loads","text":"","category":"section"},{"location":"api/#DensityFlows.save","page":"Public API","title":"DensityFlows.save","text":"save(directory, element; kws...)\n\nRecursively save the FlowElement element's weights in directory.\n\nSetting erase = true force deleted any existing directory with the same name.\n\n\n\n\n\n","category":"function"},{"location":"api/#DensityFlows.load","page":"Public API","title":"DensityFlows.load","text":"load(directory)\n\nLoad any FlowElement saved in directory.\n\n\n\n\n\n","category":"function"},{"location":"api/#Data","page":"Public API","title":"Data","text":"","category":"section"},{"location":"api/#DensityFlows.DataArrays","page":"Public API","title":"DensityFlows.DataArrays","text":"DataArrays(x, θ = nothing, f_training = 0.9, f_validation = 0.1, rng = Random.default_rng())\n\nNormalised and partitioned data to feed the neural network.\n\nx must be of size (d, ...) where d is the number of physical dimensions. θ must be of size (n, ...)  where n is the number of parameters and every other array dimensions in place of ... should match that of x. \n\nwarning: Warning\nData is partitioned along the second axis only. It is thus necessary to make sure that size(x, 2)  is large enough by swapping some of the dimensions if necessary.\n\nSee also DataPartition and MetaData.\n\n\n\n\n\n","category":"type"},{"location":"api/#DensityFlows.MetaData","page":"Public API","title":"DensityFlows.MetaData","text":"MetaData(hash, x_min, x_max, θ_min, θ_max)\n\nMetadata containing an identification hash value and the boundaries of the data and parameters arrays x and θ.\n\n\n\n\n\n","category":"type"},{"location":"api/#DensityFlows.DataPartition","page":"Public API","title":"DensityFlows.DataPartition","text":"DataPartition(n, f_training = 0.9, f_validation = 0.1, rng = Random.default_rng())\n\nRandom partition of the data.\n\nThe data is devided into a fraction f_training of training data and  a fraction f_validation of validation data. If f_training + f_validation < 1 the rest is kept as testing data. \n\n\n\n\n\n","category":"type"},{"location":"api/#DensityFlows.data_x_min","page":"Public API","title":"DensityFlows.data_x_min","text":"Minimum value of the input data.\n\n\n\n\n\n","category":"function"},{"location":"api/#DensityFlows.data_x_max","page":"Public API","title":"DensityFlows.data_x_max","text":"Maximum value of the input data.\n\n\n\n\n\n","category":"function"},{"location":"api/#DensityFlows.data_θ_min","page":"Public API","title":"DensityFlows.data_θ_min","text":"Minimin value of the input parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#DensityFlows.data_θ_max","page":"Public API","title":"DensityFlows.data_θ_max","text":"Maximum value of the input parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#DensityFlows.normalize_input","page":"Public API","title":"DensityFlows.normalize_input","text":"normalise_input(x, x_min, x_max)\n\nNormalize input between 0 1. \n\n    y = fracx - x_rm minx_rm max - x_rm min\n\nSee also normalize_input! and resize_output.\n\n\n\n\n\n","category":"function"},{"location":"api/#DensityFlows.normalize_input!","page":"Public API","title":"DensityFlows.normalize_input!","text":"normalise_input!(x, x_min, x_max)\n\nNormalize input between 0 1 in place. \n\nSee also normalize_input and resize_output!.\n\n\n\n\n\n","category":"function"},{"location":"api/#DensityFlows.resize_output","page":"Public API","title":"DensityFlows.resize_output","text":"normalise_input(x, x_min, x_max)\n\nResize the output between x_rm min x_rm max. \n\n    x = (x_rm max - x_rm min) y + x_rm min\n\nSee also resize_output! and normalize_input.\n\n\n\n\n\n","category":"function"},{"location":"api/#DensityFlows.resize_output!","page":"Public API","title":"DensityFlows.resize_output!","text":"normalise_input!(x, x_min, x_max)\n\nResize the output between x_rm min x_rm max in place. \n\nSee also resize_output and normalize_input!.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Quick-start-guide","page":"Manual","title":"Quick start guide","text":"","category":"section"},{"location":"manual/#Example","page":"Manual","title":"Example","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"using DensityFlows\n\nx = rand(2, 5000);\n\ndata = DataArrays(x)\nflow = AffineCouplingFlow(3, data.metadata, n_sublayers_s=2, n_sublayers_t=2)","category":"page"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"julia> AffineCouplingElement <: FlowElement\ntrue","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> AffineCouplingLayer <: AffineCouplingElement\ntrue","category":"page"}]
}
